// Generated by CoffeeScript 1.6.3
(function() {
  var Parser, cssParse, langCodes, reBr, reBrokenTag, reComment, reLineEnding, reOpenSync, reStartTime, reStyle;

  cssParse = require('css-parse');

  langCodes = require('./lang_codes.js');

  function strip_tags(input, allowed) {
  // http://kevin.vanzonneveld.net
  // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   improved by: Luke Godfrey
  // +      input by: Pul
  // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   bugfixed by: Onno Marsman
  // +      input by: Alex
  // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +      input by: Marc Palau
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +      input by: Brett Zamir (http://brett-zamir.me)
  // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   bugfixed by: Eric Nagel
  // +      input by: Bobby Drake
  // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +   bugfixed by: Tomasz Wesolowski
  // +      input by: Evertjan Garretsen
  // +    revised by: Rafa≈Ç Kukawski (http://blog.kukawski.pl/)
  // *     example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>');
  // *     returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
  // *     example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>');
  // *     returns 2: '<p>Kevin van Zonneveld</p>'
  // *     example 3: strip_tags("<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>", "<a>");
  // *     returns 3: '<a href='http://kevin.vanzonneveld.net'>Kevin van Zonneveld</a>'
  // *     example 4: strip_tags('1 < 5 5 > 1');
  // *     returns 4: '1 < 5 5 > 1'
  // *     example 5: strip_tags('1 <br/> 1');
  // *     returns 5: '1  1'
  // *     example 6: strip_tags('1 <br/> 1', '<br>');
  // *     returns 6: '1  1'
  // *     example 7: strip_tags('1 <br/> 1', '<br><br/>');
  // *     returns 7: '1 <br/> 1'
  allowed = (((allowed || "") + "").toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join(''); // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi,
    commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;
  return input.replace(commentsAndPhpTags, '').replace(tags, function($0, $1) {
    return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
  });
};

  reOpenSync = /<sync/i;

  reLineEnding = /\r\n?|\n/g;

  reBrokenTag = /<[a-z]*[^>]*<[a-z]*/g;

  reStartTime = /<sync[^>]+?start[^=]*=[^0-9]*([0-9]*)["^0-9"]*/i;

  reBr = /<br[^>]*>/ig;

  reStyle = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;

  reComment = /(<!--|-->)/g;

  Parser = (function() {
    Parser.defaultLanguage = {
      className: 'KRCC',
      lang: 'ko',
      reClassName: /class[^=]*?=["']?(KRCC)["']?/i
    };

    Parser.defaultLanguageCode = 'ko';

    Parser.prototype.availableLanguages = null;

    Parser.prototype.errors = null;

    function Parser() {
      this.errors = [];
      this.availableLanguages = [];
    }

    Parser.prototype._parse = function(str) {
      var e, element, i, innerText, isBroken, item, lang, lineNum, nextStartTagIdx, ret, startTagIdx, startTime, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      lineNum = 1;
      ret = [];
      while (true) {
        startTagIdx = str.search(reOpenSync);
        if (nextStartTagIdx <= 0 || startTagIdx < 0) {
          break;
        }
        nextStartTagIdx = str.slice(startTagIdx + 1).search(reOpenSync) + 1;
        if (nextStartTagIdx > 0) {
          element = str.slice(startTagIdx, startTagIdx + nextStartTagIdx);
        } else {
          element = str.slice(startTagIdx);
        }
        lineNum += ((_ref = str.slice(0, startTagIdx).match(reLineEnding)) != null ? _ref.length : void 0) || 0;
        if (isBroken = reBrokenTag.test(element)) {
          e = new Error('ERROR_BROKEN_TAGS');
          e.line = lineNum;
          e.context = element;
          this.errors.push(e);
        }
        str = str.slice(startTagIdx + nextStartTagIdx);
        startTime = +((_ref1 = element.match(reStartTime)) != null ? _ref1[1] : void 0) || -1;
        if (startTime < 0) {
          e = new Error('ERROR_INVALID_TIME');
          e.line = lineNum;
          e.context = element;
          this.errors.push(e);
        }
        lineNum += ((_ref2 = element.match(reLineEnding)) != null ? _ref2.length : void 0) || 0;
        _ref3 = this.availableLanguages;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          lang = _ref3[_i];
          if (!(lang.reClassName.test(element))) {
            continue;
          }
          lang = lang.lang;
          break;
        }
        lang || (lang = this.defaultLanguageCode);
        element = element.replace(reLineEnding, '');
        element = element.replace(reBr, "\n");
        innerText = strip_tags(element).trim();
        lang = this.getLanguage(element);
        item = {
          startTime: startTime,
          languages: {},
          contents: innerText
        };
        item.languages[lang] = innerText;
        ret.push(item);
      }
      ret.sort(function(a, b) {
        return a.startTime - b.startTime;
      });
      i = ret.length;
      while (i--) {
        item = ret[i];
        if ((_ref4 = ret[i - 1]) != null) {
          _ref4.endTime = item.startTime;
        }
        if (!item.contents || item.contents === '&nbsp;') {
          ret.splice(i, 1);
        } else {
          delete ret[i].contents;
        }
      }
      return ret;
    };

    Parser.prototype.getLanguage = function(element) {
      var lang, _i, _len, _ref;
      _ref = this.availableLanguages;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        lang = _ref[_i];
        if (lang.reClassName.test(element)) {
          return lang.lang;
        }
      }
      return Parser.defaultLanguage.lang;
    };

    Parser.prototype.getAvailableLanguages = function(str) {
      var className, declaration, e, error, lang, language, matched, parsed, rule, selector, _i, _len, _ref, _ref1, _results;
      try {
        matched = ((_ref = str.match(reStyle)) != null ? _ref[1] : void 0) || '';
        matched = matched.replace(reComment, '');
        parsed = cssParse(matched);
        _ref1 = parsed.stylesheet.rules;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          rule = _ref1[_i];
          selector = rule.selectors[0];
          if ((selector != null ? selector[0] : void 0) === '.') {
            _results.push((function() {
              var _j, _len1, _ref2, _results1;
              _ref2 = rule.declarations;
              _results1 = [];
              for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                declaration = _ref2[_j];
                if (declaration.property.toLowerCase() === 'lang') {
                  className = selector.slice(1);
                  lang = declaration.value.slice(0, 2);
                  if (~langCodes.indexOf(lang)) {
                    language = {
                      className: className,
                      lang: lang,
                      reClassName: new RegExp("class[^=]*?=[\"']?(" + className + ")['\"]?", 'i')
                    };
                    _results1.push(this.availableLanguages.push(language));
                  } else {
                    throw Error();
                  }
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } catch (_error) {
        e = _error;
        this.errors.push(error = new Error('ERROR_INVALID_LANGUAGE'));
        this.availableLanguages.push(Parser.defaultLanguage);
      }
    };

    Parser.prototype.parse = function(str) {
      var result;
      this.getAvailableLanguages(str);
      result = this._parse(str);
      return {
        result: result,
        errors: this.errors
      };
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
